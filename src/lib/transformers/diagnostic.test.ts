/**
 * Transformer Fidelity Diagnostic
 *
 * Runs each transformer against real production token files and real reference
 * code files. Writes outputs to diagnostic-output/ for manual inspection.
 * Structural assertions flag fidelity gaps as test failures.
 *
 * Run manually (skipped in normal CI suite):
 *   npx vitest run src/lib/transformers/diagnostic.test.ts
 */

import { describe, test, expect, beforeAll } from 'vitest';
import { readFileSync, mkdirSync, writeFileSync } from 'fs';
import { join } from 'path';
import type { FigmaColorExport } from '$lib/types.js';
import { transformToKotlin } from './kotlin.js';
import { transformToSwift } from './swift.js';
import { transformToSCSS } from './scss.js';
import { transformToTS } from './ts-web.js';
import { transformToTypography, detectTypographyConventions } from './typography.js';
import { detectConventions } from './naming.js';

// ─── Helpers ──────────────────────────────────────────────────────────────────

// import.meta.dirname = .../src/lib/transformers
// 3 levels up → project root
const PROJECT_ROOT = join(import.meta.dirname, '..', '..', '..');
const REF = join(PROJECT_ROOT, 'Reference files');
const TOKENS = join(REF, 'Figma Design tokens', 'Generated by Tokensmith plugin');
const OUTPUT = join(PROJECT_ROOT, 'diagnostic-output');

function readJson(path: string): Record<string, unknown> {
	return JSON.parse(readFileSync(path, 'utf-8'));
}

function readRef(...parts: string[]): string {
	return readFileSync(join(REF, ...parts), 'utf-8');
}

function writeOut(filename: string, content: string): void {
	mkdirSync(OUTPUT, { recursive: true });
	writeFileSync(join(OUTPUT, filename), content, 'utf-8');
}

// ─── Diagnostic Tests (skipped in CI) ────────────────────────────────────────
// All data loading is inside beforeAll so it only runs when tests execute,
// not during normal module collection / CI test runs.

describe('Transformer Fidelity Diagnostic — run manually with: npx vitest run src/lib/transformers/diagnostic.test.ts', () => {
	let lightTokens: Record<string, unknown>;
	let darkTokens: Record<string, unknown>;
	let typographyTokens: Record<string, unknown>;
	let colorKtRef: string;
	let rFillColorsRef: string;
	let rTextColorsRef: string;
	let rIconColorsRef: string;
	let rStrokeColorsRef: string;
	let rBackgroundColorsRef: string;
	let colorsSwiftRef: string;
	let primitivesScssRef: string;
	let colorScssRef: string;
	let primitivesTsRef: string;
	let colorTsRef: string;
	let typographyScssRef: string;
	let allKotlinRefs: string;

	beforeAll(() => {
		lightTokens        = readJson(join(TOKENS, 'light.tokens.json'));
		darkTokens         = readJson(join(TOKENS, 'dark.tokens.json'));
		typographyTokens   = readJson(join(TOKENS, 'typography.tokens.json'));

		colorKtRef          = readRef('Android', 'Colors', 'Color.kt');
		rFillColorsRef      = readRef('Android', 'Colors', 'RFillColors.kt');
		rTextColorsRef      = readRef('Android', 'Colors', 'RTextColors.kt');
		rIconColorsRef      = readRef('Android', 'Colors', 'RIconColors.kt');
		rStrokeColorsRef    = readRef('Android', 'Colors', 'RStrokeColors.kt');
		rBackgroundColorsRef = readRef('Android', 'Colors', 'RBackgroundColors.kt');

		colorsSwiftRef      = readRef('iOS', 'Colors', 'Colors.swift');

		primitivesScssRef   = readRef('Web', 'Colors', 'Primitives.scss');
		colorScssRef        = readRef('Web', 'Colors', 'Colors.scss');
		primitivesTsRef     = readRef('Web', 'Colors', 'Primitives.ts');
		colorTsRef          = readRef('Web', 'Colors', 'Colors.ts');
		typographyScssRef   = readRef('Web', 'Typography', 'Typography.scss');

		allKotlinRefs = [
			colorKtRef,
			rFillColorsRef,
			rTextColorsRef,
			rIconColorsRef,
			rStrokeColorsRef,
			rBackgroundColorsRef
		].join('\n');
	});

	// ── Android Kotlin ────────────────────────────────────────────────────────

	test('Android Kotlin — multi-file generation matches reference structure', () => {
		const results = transformToKotlin(
			lightTokens as FigmaColorExport,
			darkTokens as FigmaColorExport,
			allKotlinRefs,
			false // match-existing mode
		);

		for (const r of results) {
			writeOut(`android-${r.filename}`, r.content);
		}

		// Should produce multiple files (primitives + per-category)
		expect(results.length, 'Should generate more than one file').toBeGreaterThan(1);

		// Color.kt (primitives) must be present
		const colorKt = results.find((r) => r.filename === 'Color.kt');
		expect(colorKt, 'Color.kt should be generated').toBeDefined();

		// Find the fill category file
		const fillFile = results.find((r) => r.filename.toLowerCase().includes('fill'));
		expect(fillFile, 'A fill colors file should be generated').toBeDefined();

		if (fillFile) {
			const c = fillFile.content;

			// P1: enum class with SCREAMING_SNAKE_CASE values (not run-together uppercase)
			expect(c, 'Should contain enum class declaration').toContain('enum class');
			expect(c, 'Enum values should use SCREAMING_SNAKE_CASE with underscores').toMatch(/\bFILL_[A-Z]+_[A-Z]+\b/);
			expect(c, 'Should NOT have run-together ALL_CAPS enum values').not.toMatch(/\bFILL[A-Z]{5,}\b/);

			// P2: CompositionLocal holder should be var (not val)
			expect(c, 'Local CompositionLocal holder should be var').toMatch(/\bvar Local\w+Color\b/);

			// P2: MaterialTheme extension must have type annotation
			expect(c, 'MaterialTheme extension should carry a type annotation').toMatch(/LocalFillColors:\s*\w+/);

			// CompositionLocal pattern present
			expect(c, 'Should contain compositionLocalOf').toContain('compositionLocalOf');
		}
	});

	test('Android Kotlin — enum when() branches map to camelCase property names', () => {
		const results = transformToKotlin(
			lightTokens as FigmaColorExport,
			darkTokens as FigmaColorExport,
			allKotlinRefs,
			false
		);

		const fillFile = results.find((r) => r.filename.toLowerCase().includes('fill'));
		if (!fillFile) return;

		// when() branches: SCREAMING_SNAKE → camelCase property on LocalFillColors
		expect(fillFile.content, 'when() branch should reference camelCase property').toMatch(
			/FILL_\w+ -> MaterialTheme\.Local\w+Colors\.\w+[a-z]/
		);
	});

	// ── iOS Swift ─────────────────────────────────────────────────────────────

	test('iOS Swift — three-tier architecture is reproduced', () => {
		const result = transformToSwift(
			lightTokens as FigmaColorExport,
			darkTokens as FigmaColorExport,
			colorsSwiftRef,
			false // match-existing mode
		);

		writeOut('ios-Colors.swift', result.content);

		const c = result.content;

		// Tier 1: fileprivate primitive enum
		expect(c, 'Tier 1: Should contain fileprivate enum').toMatch(/fileprivate\s+enum\s+\w+/);

		// Tier 2: flat Light/Dark semantic enum
		expect(c, 'Tier 2: Should contain semantic color enum').toMatch(/enum\s+\w+(?:Codes|Colors|Semantic)/);

		// Tier 3: UIColor public API
		expect(c, 'Tier 3: Should contain UIColor API enum').toContain('UIColor');
		expect(c, 'Tier 3: Should contain UIColor | operator').toContain('infix operator |');

		// Reference uses string hex, NOT Color(hex:)
		expect(c, 'Should NOT use Color(hex: — reference uses string literals').not.toContain('Color(hex:');

		// P4: Primitive hex strings should NOT embed alpha (no 8-char hex literals)
		// The reference stores base RGB; alpha is applied via suiColor(lightRef, darkRef, alpha)
		const eightCharHex = /"#[0-9A-Fa-f]{8}"/g;
		const eightHexMatches = c.match(eightCharHex);
		expect(eightHexMatches, 'Primitive hex strings should NOT embed alpha').toBeNull();
	});

	// ── Web SCSS ──────────────────────────────────────────────────────────────

	test('Web SCSS — conventions detected and applied from reference', () => {
		const conventions = detectConventions(
			primitivesScssRef,
			colorScssRef,
			primitivesTsRef,
			colorTsRef,
			false // match-existing
		);

		const results = transformToSCSS(
			lightTokens as FigmaColorExport,
			darkTokens as FigmaColorExport,
			conventions,
			undefined,
			new Map(),
			() => false,
			false
		);

		for (const r of results) {
			writeOut(`web-${r.filename}`, r.content);
		}

		const primitivesScss = results.find((r) => r.filename === 'Primitives.scss');
		const colorsScss = results.find((r) => r.filename === 'Colors.scss');

		expect(primitivesScss, 'Primitives.scss should be generated').toBeDefined();
		expect(colorsScss, 'Colors.scss should be generated').toBeDefined();

		if (primitivesScss) {
			// Reference uses @import, not @use
			expect(primitivesScss.content, 'Should NOT use @use (reference uses @import)').not.toContain('@use');
			// Hyphen separator: $grey-750
			expect(primitivesScss.content, 'Should use hyphen separator').toMatch(/\$\w+-\d+/);
		}

		if (colorsScss) {
			expect(colorsScss.content, 'Should contain semantic color tokens').toMatch(/\$(fill|text|stroke|background|icon)-/i);
		}
	});

	// ── Web TypeScript ────────────────────────────────────────────────────────

	test('Web TypeScript — SCREAMING_SNAKE_CASE exports match reference', () => {
		const conventions = detectConventions(
			primitivesScssRef,
			colorScssRef,
			primitivesTsRef,
			colorTsRef,
			false
		);

		const results = transformToTS(
			lightTokens as FigmaColorExport,
			darkTokens as FigmaColorExport,
			conventions,
			undefined,
			new Map(),
			() => false,
			false
		);

		for (const r of results) {
			writeOut(`web-${r.filename}`, r.content);
		}

		const primitivesTs = results.find((r) => r.filename === 'Primitives.ts');
		const colorsTs = results.find((r) => r.filename === 'Colors.ts');

		expect(primitivesTs, 'Primitives.ts should be generated').toBeDefined();
		if (primitivesTs) {
			expect(primitivesTs.content, 'Should use SCREAMING_SNAKE_CASE exports').toMatch(/export const [A-Z][A-Z_\d]+\s*=/);
		}

		if (colorsTs) {
			expect(colorsTs.content, 'Should contain SCREAMING_SNAKE_CASE semantic tokens').toMatch(/export const [A-Z][A-Z_]+\s*=/);
		}
	});

	// ── Web Typography SCSS ───────────────────────────────────────────────────

	test('Web Typography SCSS — two-tier: variables AND @mixin declarations', () => {
		const conventions = detectTypographyConventions(typographyScssRef, undefined, false);

		const results = transformToTypography(typographyTokens, ['web'], conventions);

		for (const r of results) {
			writeOut(`web-typo-${r.filename}`, r.content);
		}

		const typoScss = results.find((r) => r.filename === 'Typography.scss');
		expect(typoScss, 'Typography.scss should be generated').toBeDefined();

		if (typoScss) {
			const c = typoScss.content;

			// Should have SCSS size variables (names may be multi-segment, e.g. $font-xlarge-title-size:)
			expect(c, 'Should contain $font-*-size variables').toMatch(/\$\w+-[\w-]+-size:/);

			// P5: Should contain @mixin declarations
			expect(c, 'Should contain @mixin declarations').toContain('@mixin ');

			// Mixin prefix should be short shared prefix (e.g. "font-"), not a compound one
			const mixinLines = c.split('\n').filter((l) => l.startsWith('@mixin '));
			if (mixinLines.length > 0) {
				expect(mixinLines[0], 'First mixin should use the common prefix').toMatch(/^@mixin \w+-\w+/);
			}
		}
	});
});
